/**
 * Copyright (c) 2010-2018 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package org.openhab.binding.neeo.internal.type;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import org.apache.commons.lang.StringUtils;
import org.eclipse.jdt.annotation.NonNullByDefault;
import org.eclipse.smarthome.config.core.ConfigDescription;
import org.eclipse.smarthome.config.core.ConfigDescriptionParameter;
import org.eclipse.smarthome.config.core.ConfigDescriptionParameter.Type;
import org.eclipse.smarthome.config.core.ConfigDescriptionParameterBuilder;
import org.eclipse.smarthome.config.core.ConfigDescriptionParameterGroup;
import org.eclipse.smarthome.core.thing.ThingTypeUID;
import org.eclipse.smarthome.core.thing.type.ChannelGroupDefinition;
import org.eclipse.smarthome.core.thing.type.ThingType;
import org.eclipse.smarthome.core.thing.type.ThingTypeBuilder;
import org.openhab.binding.neeo.NeeoConstants;
import org.openhab.binding.neeo.NeeoUtil;
import org.openhab.binding.neeo.internal.models.NeeoDevice;
import org.openhab.binding.neeo.internal.models.NeeoRoom;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;
import com.google.gson.JsonParseException;

/**
 * Generates ThingTypes based on metadata from the {@link NeeoRoom}. Whenever a new thing type is generated (room or
 * device), the information to generate the thing type will be serialized and stored in a file. When the system is
 * restarted and activation is called, that file will be restored and will automatically regenerate those thing types.
 *
 * @author Tim Roberts - Initial Contribution
 */
@NonNullByDefault
@Component(immediate = true)
public class NeeoTypeGeneratorImpl implements NeeoTypeGenerator {

    /** The logger */
    private final Logger logger = LoggerFactory.getLogger(NeeoTypeGeneratorImpl.class);

    /** The thing type provider */
    @NonNullByDefault({})
    private NeeoThingTypeProvider thingTypeProvider;

    /** The config description provider */
    @NonNullByDefault({})
    private NeeoConfigDescriptionProvider configDescriptionProvider;

    /** The channel type provider */
    @NonNullByDefault({})
    private NeeoChannelTypeProvider channelTypeProvider;

    /** The file we store thing type information in */
    private final File thingTypesFile = new File(NeeoConstants.FILENAME_THINGTYPES);

    /** The storage for all things generated by this class. Will be used to serialize/deserialize */
    private final Storage storage = new Storage();

    /** Used to serialize/deserialize {@link #storage} in the thing types file */
    private final Gson gson = new Gson();

    /**
     * Sets the thing type provider.
     *
     * @param thingTypeProvider the non-null thing type provider
     */
    @Reference(cardinality = ReferenceCardinality.MANDATORY, service = NeeoThingTypeProvider.class, name = "ThingTypeProvider", policy = ReferencePolicy.DYNAMIC, unbind = "unsetThingTypeProvider")
    public void setThingTypeProvider(NeeoThingTypeProvider thingTypeProvider) {
        Objects.requireNonNull(thingTypeProvider, "thingTypeProvider cannot be null");

        this.thingTypeProvider = thingTypeProvider;
    }

    /**
     * Unsets thing type provider.
     *
     * @param thingTypeProvider the thing type provider (ignored)
     */
    public void unsetThingTypeProvider(NeeoThingTypeProvider thingTypeProvider) {
        this.thingTypeProvider = null;
    }

    /**
     * Sets the channel type provider.
     *
     * @param channelTypeProvider the non-null channel type provider
     */
    @Reference(cardinality = ReferenceCardinality.MANDATORY, service = NeeoChannelTypeProvider.class, name = "ChannelTypeProvider", policy = ReferencePolicy.DYNAMIC, unbind = "unsetChannelTypeProvider")
    public void setChannelTypeProvider(NeeoChannelTypeProvider channelTypeProvider) {
        Objects.requireNonNull(channelTypeProvider, "channelTypeProvider cannot be null");

        this.channelTypeProvider = channelTypeProvider;
    }

    /**
     * Unsets channel type provider.
     *
     * @param channelTypeProvider the channel type provider (ignored)
     */
    public void unsetChannelTypeProvider(NeeoChannelTypeProvider channelTypeProvider) {
        this.channelTypeProvider = null;
    }

    /**
     * Sets the config description provider.
     *
     * @param configDescriptionProvider the non-null config description provider
     */
    @Reference(cardinality = ReferenceCardinality.MANDATORY, service = NeeoConfigDescriptionProvider.class, name = "ConfigDescriptionProvider", policy = ReferencePolicy.DYNAMIC, unbind = "unsetConfigDescriptionProvider")
    public void setConfigDescriptionProvider(NeeoConfigDescriptionProvider configDescriptionProvider) {
        Objects.requireNonNull(configDescriptionProvider, "configDescriptionProvider cannot be null");
        this.configDescriptionProvider = configDescriptionProvider;
    }

    /**
     * Unset config description provider.
     *
     * @param configDescriptionProvider the config description provider (ignored)
     */
    public void unsetConfigDescriptionProvider(NeeoConfigDescriptionProvider configDescriptionProvider) {
        this.configDescriptionProvider = null;
    }

    @Override
    public void generate(String brainId, NeeoRoom room) {
        NeeoUtil.requireNotEmpty(brainId, "brainId cannot be empty");
        Objects.requireNonNull(room, "room cannot be null");

        generateThingType(brainId, room);
        storage.addRoom(brainId, room);
        save();
    }

    /**
     * Helper method to generate the thing type from the given brain identifier and room. The thing type will then be
     * stored in the {@link #thingTypeProvider}.
     *
     * @param brainId a non-null, non-empty brain identifier
     * @param room a non-null room
     */
    private void generateThingType(String brainId, NeeoRoom room) {
        NeeoUtil.requireNotEmpty(brainId, "brainId cannot be empty");
        Objects.requireNonNull(room, "room cannot be null");

        final NeeoThingTypeProvider localThingTypeProvider = thingTypeProvider;
        Objects.requireNonNull(localThingTypeProvider, "thingTypeProvider cannot be null");

        logger.debug("Generating ThingType for room '{}' ({})", room.getName(), room.getKey());
        final ThingType thingType = createThingType(brainId, room);

        localThingTypeProvider.addThingType(thingType);
    }

    /**
     * Creates the ThingType for the given {@link NeeoRoom}.
     *
     * @param brainId the non-null, non-empty brainID
     * @param room the non-null room
     * @return the thing type
     */
    private ThingType createThingType(String brainId, NeeoRoom room) {
        NeeoUtil.requireNotEmpty(brainId, "brainId cannot be empty");
        Objects.requireNonNull(room, "room cannot be null");

        final NeeoConfigDescriptionProvider localConfigDescriptionProvider = configDescriptionProvider;
        Objects.requireNonNull(localConfigDescriptionProvider, "configDescriptionProvider cannot be null");

        final String label = room.getName() + " (NEEO " + brainId + ")";
        final String description = String.format("%s (%s)", label, room.getKey());

        final List<String> supportedBridgeTypeUids = new ArrayList<>();
        supportedBridgeTypeUids.add(NeeoConstants.BRIDGE_TYPE_BRAIN.toString());

        final ThingTypeUID thingTypeUID = UidUtils.generateThingTypeUID(room);

        final Map<String, String> properties = new HashMap<>();

        final URI configDescriptionURI = getConfigDescriptionURI(room);
        if (localConfigDescriptionProvider.getConfigDescription(configDescriptionURI, null) == null) {
            generateConfigDescription(room, configDescriptionURI);
        }

        final List<ChannelGroupDefinition> groupDefinitions = MetadataUtils.getGroupDefinitions(room);

        return ThingTypeBuilder.instance(thingTypeUID, label).withSupportedBridgeTypeUIDs(supportedBridgeTypeUids)
                .withDescription(description).withChannelGroupDefinitions(groupDefinitions).withProperties(properties)
                .withConfigDescriptionURI(configDescriptionURI).buildBridge();
    }

    /**
     * Generate config description.
     *
     * @param room the non-null room
     * @param configDescriptionURI the non-null config description URI
     */
    private void generateConfigDescription(NeeoRoom room, URI configDescriptionURI) {
        Objects.requireNonNull(room, "room cannot be null");
        Objects.requireNonNull(configDescriptionURI, "configDescriptionURI cannot be null");

        final NeeoConfigDescriptionProvider localConfigDescriptionProvider = configDescriptionProvider;
        Objects.requireNonNull(localConfigDescriptionProvider, "configDescriptionProvider cannot be null");

        final List<ConfigDescriptionParameter> parms = new ArrayList<>();
        final List<ConfigDescriptionParameterGroup> groups = new ArrayList<>();

        final ConfigDescriptionParameterBuilder keyParmBuilder = ConfigDescriptionParameterBuilder
                .create(NeeoConstants.CONFIG_ROOMKEY, Type.TEXT).withLabel("Room Key")
                .withDescription("Unique key of the room").withRequired(true);
        parms.add(keyParmBuilder.build());

        final ConfigDescriptionParameterBuilder pollingParmBuilder = ConfigDescriptionParameterBuilder
                .create(NeeoConstants.CONFIG_REFRESH_POLLING, Type.INTEGER).withLabel("Refresh Polling")
                .withDescription("The time (in seconds) to refresh state (<= 0 to disable)").withDefault("120")
                .withAdvanced(true);
        parms.add(pollingParmBuilder.build());

        final ConfigDescriptionParameterBuilder exludeParmBuilder = ConfigDescriptionParameterBuilder
                .create(NeeoConstants.CONFIG_EXCLUDE_THINGS, Type.BOOLEAN).withLabel("Exclude Things")
                .withDescription("Exclude openHAB things (from NEEO transport)").withDefault("true").withAdvanced(true);
        parms.add(exludeParmBuilder.build());

        localConfigDescriptionProvider.addConfigDescription(new ConfigDescription(configDescriptionURI, parms, groups));
    }

    /**
     * Gets the config description URI for the room
     *
     * @param room the non-null room
     * @return the config description URI
     */
    private URI getConfigDescriptionURI(NeeoRoom room) {
        Objects.requireNonNull(room, "room cannot be null");

        try {
            return new URI(String.format("%s:%s", NeeoConstants.CONFIG_DESCRIPTION_URI_ROOM,
                    UidUtils.generateThingTypeUID(room)));
        } catch (URISyntaxException ex) {
            throw new UnsupportedOperationException("Can't create configDescriptionURI for room " + room.getKey());
        }
    }

    @Override
    public void generate(String brainId, ThingTypeUID roomUid, NeeoDevice device) {
        NeeoUtil.requireNotEmpty(brainId, "brainId cannot be null");
        Objects.requireNonNull(roomUid, "roomUid cannot be null");
        Objects.requireNonNull(device, "device cannot be null");

        generateThingType(brainId, roomUid, device);
        storage.addDevice(brainId, roomUid, device);
        save();
    }

    /**
     * Helper method to generate the thing type from the given brain identifier, room type UID and device. The thing
     * type will then be stored in the {@link #thingTypeProvider}.
     *
     * @param brainId a non-null, non-empty brain identifier
     * @param roomUid a non-null room thing type identifer
     * @param device a non-null device
     */
    private void generateThingType(String brainId, ThingTypeUID roomUid, NeeoDevice device) {
        NeeoUtil.requireNotEmpty(brainId, "brainId cannot be null");
        Objects.requireNonNull(roomUid, "roomUid cannot be null");
        Objects.requireNonNull(device, "device cannot be null");

        final NeeoThingTypeProvider localThingTypeProvider = thingTypeProvider;
        Objects.requireNonNull(localThingTypeProvider, "thingTypeProvider cannot be null");

        logger.debug("Generating ThingType for device '{}' ({})", device.getName(), device.getKey());
        final ThingType thingType = createThingType(brainId, roomUid, device);

        localThingTypeProvider.addThingType(thingType);
    }

    /**
     * Creates the ThingType for the given {@link NeeoDevice}.
     *
     * @param brainId the non-null, non-empty brainID
     * @param roomUid the non-null room Uid
     * @param device the non-null device
     * @return the thing type
     */
    private ThingType createThingType(String brainId, ThingTypeUID roomUid, NeeoDevice device) {
        NeeoUtil.requireNotEmpty(brainId, "brainId cannot be empty");
        Objects.requireNonNull(roomUid, "roomUid cannot be null");
        Objects.requireNonNull(device, "device cannot be null");

        final NeeoConfigDescriptionProvider localConfigDescriptionProvider = configDescriptionProvider;
        Objects.requireNonNull(localConfigDescriptionProvider, "configDescriptionProvider cannot be null");

        final NeeoChannelTypeProvider localChannelTypeProvider = channelTypeProvider;
        Objects.requireNonNull(localChannelTypeProvider, "channelTypeProvider cannot be null");

        final String label = device.getName() + " (NEEO " + brainId + ")";
        final String description = String.format("%s (%s)", label, device.getKey());

        final List<String> supportedBridgeTypeUids = new ArrayList<>();
        supportedBridgeTypeUids.add(roomUid.toString());

        final ThingTypeUID thingTypeUID = UidUtils.generateThingTypeUID(device);

        final Map<String, String> properties = new HashMap<>();

        final URI configDescriptionURI = getConfigDescriptionURI(device);
        if (localConfigDescriptionProvider.getConfigDescription(configDescriptionURI, null) == null) {
            generateConfigDescription(device, configDescriptionURI);
        }

        localChannelTypeProvider.addChannelGroupTypes(MetadataUtils.getChannelGroupTypes(device));
        localChannelTypeProvider.addChannelTypes(MetadataUtils.getChannelTypes(device));

        final List<ChannelGroupDefinition> groupDefinitions = MetadataUtils.getGroupDefinitions(device);

        return ThingTypeBuilder.instance(thingTypeUID, label).withSupportedBridgeTypeUIDs(supportedBridgeTypeUids)
                .withDescription(description).withChannelGroupDefinitions(groupDefinitions).withProperties(properties)
                .withConfigDescriptionURI(configDescriptionURI).build();
    }

    /**
     * Generate config description.
     *
     * @param device the non-null device
     * @param configDescriptionURI the non-null config description URI
     */
    private void generateConfigDescription(NeeoDevice device, URI configDescriptionURI) {
        Objects.requireNonNull(device, "device cannot be null");
        Objects.requireNonNull(configDescriptionURI, "configDescriptionURI cannot be null");

        final NeeoConfigDescriptionProvider localConfigDescriptionProvider = configDescriptionProvider;
        Objects.requireNonNull(localConfigDescriptionProvider, "configDescriptionProvider cannot be null");

        final List<ConfigDescriptionParameter> parms = new ArrayList<>();
        final List<ConfigDescriptionParameterGroup> groups = new ArrayList<>();

        final ConfigDescriptionParameterBuilder keyParmBuilder = ConfigDescriptionParameterBuilder
                .create(NeeoConstants.CONFIG_DEVICEKEY, Type.TEXT).withLabel("Device Key")
                .withDescription("Unique key of the device").withRequired(true);
        parms.add(keyParmBuilder.build());

        localConfigDescriptionProvider.addConfigDescription(new ConfigDescription(configDescriptionURI, parms, groups));
    }

    /**
     * Gets the config description URI for the device
     *
     * @param device the non-null device
     * @return the config description URI
     */
    private URI getConfigDescriptionURI(NeeoDevice device) {
        Objects.requireNonNull(device, "device cannot be null");

        try {
            return new URI(String.format("%s:%s", NeeoConstants.CONFIG_DESCRIPTION_URI_DEVICE,
                    UidUtils.generateThingTypeUID(device)));
        } catch (URISyntaxException ex) {
            throw new UnsupportedOperationException(
                    "Can't create configDescriptionURI for device {}" + device.getKey());
        }
    }

    @Activate
    protected void activate(ComponentContext componentContext) {
        restore();
    }

    @Deactivate
    protected void deactivate(ComponentContext componentContext) {
        save();
    }

    /**
     * Saves the storage information to the {@link #thingTypesFile}
     */
    private void save() {
        logger.debug("Saving NEEO thing types to {}", thingTypesFile.toPath());
        try {
            // ensure full path exists
            thingTypesFile.getParentFile().mkdirs();

            final String json = gson.toJson(storage);
            final byte[] contents = json.getBytes(StandardCharsets.UTF_8);
            Files.write(thingTypesFile.toPath(), contents);
        } catch (IOException e) {
            logger.debug("IOException writing {}: {}", thingTypesFile.toPath(), e.getMessage(), e);
        }
    }

    /**
     * Restores the storage information from the {@link #thingTypesFile} and regenerates the things types specified
     * within that storage
     */
    private void restore() {
        if (thingTypesFile.exists()) {
            try {
                logger.debug("Reading contents of {}", thingTypesFile.getAbsolutePath());
                final byte[] contents = Files.readAllBytes(thingTypesFile.toPath());
                final String json = new String(contents, StandardCharsets.UTF_8);

                final Storage lastStorage = gson.fromJson(json, Storage.class);

                // The following will add the information to our current storage
                // and then regenerate the thing type. save() will NOT be called
                // since we are reading from the storage
                for (Storage.RoomInfo room : lastStorage.rooms) {
                    storage.addRoom(room.brainId, room.room);
                    generateThingType(room.brainId, room.room);
                }
                for (Storage.DeviceInfo device : lastStorage.devices) {
                    storage.addDevice(device.brainId, device.roomUid, device.device);
                    generateThingType(device.brainId, device.roomUid, device.device);
                }
            } catch (JsonParseException | UnsupportedOperationException e) {
                logger.debug("JsonParseException reading {}: {}", thingTypesFile.toPath(), e.getMessage(), e);
            } catch (IOException e) {
                logger.debug("IOException reading {}: {}", thingTypesFile.toPath(), e.getMessage(), e);
            }
        }
    }

    /**
     * This class represents the storage of items needed to recreate the various thing types. The storage will store
     * both rooms and devices (brains are not dynamically generated). This class will be serialized and deserialzed by
     * the GSON.
     *
     * @author Tim Roberts - Initial Contribution
     *
     */
    private class Storage {
        /** the room information that will be stored */
        private final List<RoomInfo> rooms = new ArrayList<>();

        /** The device information that will be stored */
        private final List<DeviceInfo> devices = new ArrayList<>();

        /**
         * Adds a new room to the storage. If the room already exists, it will be replaced
         *
         * @param brainId a non-null, non-empty brain ID
         * @param room a non-null room
         */
        private void addRoom(String brainId, NeeoRoom room) {
            NeeoUtil.requireNotEmpty(brainId, "brainId cannot be empty");
            Objects.requireNonNull(room, "room cannot be null");

            final String roomKey = room.getKey();
            if (roomKey == null || StringUtils.isEmpty(roomKey)) {
                logger.debug("Cannot add the room - no room key: {} {}", brainId, room);
            } else {
                removeRoom(brainId, roomKey);
                rooms.add(new RoomInfo(brainId, room));
            }
        }

        /**
         * Removes the specified room from the storage.
         *
         * @param brainId a non-null, non-empty brain ID
         * @param roomKey a non-null, non-empty room key
         */
        private void removeRoom(String brainId, String roomKey) {
            NeeoUtil.requireNotEmpty(brainId, "brainId cannot be Empty");
            NeeoUtil.requireNotEmpty(roomKey, "roomKey cannot be Empty");
            rooms.removeIf(roomStorage -> StringUtils.equals(brainId, roomStorage.brainId)
                    && StringUtils.equals(roomKey, roomStorage.room.getKey()));
        }

        /**
         * Adds a new device to the storage. If the device already exists, it will be replaced
         *
         * @param brainId a non-null, non-empty brain ID
         * @param roomUid a non-null room UID
         * @param device a non-null device
         */
        private void addDevice(String brainId, ThingTypeUID roomUid, NeeoDevice device) {
            NeeoUtil.requireNotEmpty(brainId, "brainId cannot be empty");
            Objects.requireNonNull(roomUid, "roomUid cannot be null");
            Objects.requireNonNull(device, "device cannot be null");

            final String deviceKey = device.getKey();
            if (deviceKey == null || StringUtils.isEmpty(deviceKey)) {
                logger.debug("Cannot add the device - no device key: {} {} {}", brainId, roomUid, device);
            } else {
                removeDevice(brainId, deviceKey);
                devices.add(new DeviceInfo(brainId, roomUid, device));
            }
        }

        /**
         * Removes the specified device from the storage.
         *
         * @param brainId a non-null, non-empty brain ID
         * @param deviceKey a non-null, non-empty device key
         */
        private void removeDevice(String brainId, String deviceKey) {
            NeeoUtil.requireNotEmpty(brainId, "brainId cannot be Empty");
            NeeoUtil.requireNotEmpty(deviceKey, "deviceKey cannot be Empty");
            devices.removeIf(deviceStorage -> StringUtils.equals(brainId, deviceStorage.brainId)
                    && StringUtils.equals(deviceKey, deviceStorage.device.getKey()));
        }

        /**
         * Removes the all rooms and devices for the specified brain
         *
         * @param brainId a non-null, non-empty brain ID
         */
        private void removeBrain(String brainId) {
            NeeoUtil.requireNotEmpty(brainId, "brainId cannot be Empty");

            rooms.removeIf(roomStorage -> StringUtils.equals(brainId, roomStorage.brainId));
            devices.removeIf(deviceStorage -> StringUtils.equals(brainId, deviceStorage.brainId));

        }

        /**
         * This class represents the room information that will be used to recreate a room thing type. This class will
         * be serialized/deserialized with the Storage.
         * 
         * @author Tim Roberts - Initial Contributions
         */
        private class RoomInfo {
            /** The brain ID of the room */
            private final String brainId;
            /** The room itself */
            private final NeeoRoom room;

            /**
             * Constructs the room information from the brain ID and room
             * 
             * @param brainId a non-null, non-empty brain ID
             * @param room a non-null room
             */
            private RoomInfo(String brainId, NeeoRoom room) {
                NeeoUtil.requireNotEmpty(brainId, "brainId cannot be empty");
                Objects.requireNonNull(room, "room cannot be empty");
                this.brainId = brainId;
                this.room = room;
            }
        }

        /**
         * This class represents the device information that will be used to recreate a device thing type. This class
         * will be serialized/deserialized with the Storage.
         * 
         * @author Tim Roberts - Initial Contributions
         */
        private class DeviceInfo {
            /** The brain ID of the device */
            private final String brainId;
            /**
             * The room type UID (assumes the room UID is based on the non-changing room key and not some other scheme)
             */
            private final ThingTypeUID roomUid;
            /** The device */
            private final NeeoDevice device;

            /**
             * Constructs the device information from the brain ID, room UID and device
             * 
             * @param brainId a non-null, non-empty brain ID
             * @param roomUid a non-null room UID
             * @param device a non-null device
             */
            private DeviceInfo(String brainId, ThingTypeUID roomUid, NeeoDevice device) {
                NeeoUtil.requireNotEmpty(brainId, "brainId cannot be empty");
                Objects.requireNonNull(roomUid, "roomUid cannot be empty");
                Objects.requireNonNull(device, "device cannot be empty");
                this.brainId = brainId;
                this.roomUid = roomUid;
                this.device = device;
            }
        }
    }

    @Override
    public void removeBrain(String brainId) {
        NeeoUtil.requireNotEmpty(brainId, "brainId cannot be empty");
        storage.removeBrain(brainId);
        save();
    }

    @Override
    public void removeRoom(String brainId, String roomKey) {
        NeeoUtil.requireNotEmpty(brainId, "brainId cannot be empty");
        NeeoUtil.requireNotEmpty(roomKey, "roomKey cannot be empty");
        storage.removeRoom(brainId, roomKey);
        save();
    }

    @Override
    public void removeDevice(String brainId, String deviceKey) {
        NeeoUtil.requireNotEmpty(brainId, "brainId cannot be empty");
        NeeoUtil.requireNotEmpty(deviceKey, "deviceKey cannot be empty");
        storage.removeDevice(brainId, deviceKey);
        save();
    }
}
